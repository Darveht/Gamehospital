<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hospital Abandonado 3D - Juego de Terror</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            cursor: none;
            touch-action: none;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #flashlightBattery {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .battery-icon {
            font-size: 20px;
        }

        .battery-bar {
            width: 100px;
            height: 15px;
            border: 2px solid #666;
            border-radius: 3px;
            background: #222;
            overflow: hidden;
        }

        .battery-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #F44336);
            transition: width 0.3s ease;
            width: 100%;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #888;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        #mobileControls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            pointer-events: auto;
        }

        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
            
            #instructions {
                font-size: 10px;
                bottom: 80px;
            }
        }

        .mobile-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 15px;
            margin: 5px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }

        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        #joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
            pointer-events: auto;
        }

        @media (max-width: 768px) {
            #joystick {
                display: block;
            }
        }

        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #ff4444;
            padding: 40px;
            border: 3px solid #666;
            text-align: center;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: auto;
        }

        #gameOverScreen h1 {
            margin-bottom: 20px;
            animation: flicker 0.5s infinite alternate;
        }

        #restartBtn {
            background: #333;
            color: #fff;
            border: 2px solid #666;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        #restartBtn:hover {
            background: #555;
            border-color: #888;
        }

        .hidden {
            display: none !important;
        }

        @keyframes flicker {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            font-size: 20px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #floorIndicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div id="flashlightBattery">
                <div class="battery-icon">ðŸ”‹</div>
                <div class="battery-bar">
                    <div id="batteryLevel" class="battery-fill"></div>
                </div>
                <span id="batteryPercent">100%</span>
            </div>
            
            <div id="floorIndicator">
                <span id="currentFloor">Planta Baja</span>
            </div>
            
            <div id="instructions">
                PC: WASD - Mover | Mouse - Mirar | Click/Espacio - Linterna<br>
                MÃ³vil: Joystick - Mover | Tocar pantalla - Mirar | BotÃ³n - Linterna<br>
                E - Usar escaleras
            </div>
            <div id="crosshair">âœš</div>
            
            <!-- Mobile controls -->
            <div id="joystick">
                <div id="joystickKnob"></div>
            </div>
            <div id="mobileControls">
                <button class="mobile-btn" id="flashlightBtn">ðŸ’¡</button>
                <button class="mobile-btn" id="useBtn">E</button>
            </div>
            
            <div id="gameOverScreen" class="hidden">
                <h1>LA OSCURIDAD TE CONSUME...</h1>
                <button id="restartBtn">Reintentar</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class HorrorGame3D {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFShadowMap;
                this.renderer.setClearColor(0x000000);
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);

                // Player properties
                this.player = {
                    x: 0,
                    y: 1.7,
                    z: 0,
                    speed: 0.15,
                    height: 1.7,
                    currentFloor: 0
                };

                // Movement and rotation
                this.keys = {};
                this.yaw = 0;
                this.pitch = 0;
                this.sensitivity = 0.002;

                // Mobile controls
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.joystick = {
                    active: false,
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0
                };
                this.touchLook = {
                    active: false,
                    lastX: 0,
                    lastY: 0
                };

                // Flashlight properties
                this.flashlight = {
                    on: true,
                    battery: 100,
                    drainRate: 0.01, // BaterÃ­a mÃ¡s duradera
                    light: null
                };

                // Game state
                this.gameOver = false;
                this.timeElapsed = 0;
                this.paranormalEvents = [];
                this.nearStairs = false;

                this.init();
            }

            init() {
                this.setupCamera();
                this.createHospital();
                this.createLighting();
                this.setupControls();
                this.gameLoop();
                this.startParanormalEvents();
            }

            setupCamera() {
                this.camera.position.set(this.player.x, this.player.y, this.player.z);
                this.camera.rotation.order = 'YXZ';
            }

            createHospital() {
                // Suelo principal
                const floorGeometry = new THREE.PlaneGeometry(200, 200);
                const floorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x1a1a1a,
                    transparent: true,
                    opacity: 0.9
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);

                this.createWalls();
                this.createRooms();
                this.createFurniture();
                this.createStaircase();
                this.createBloodStains();
            }

            createWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const wallHeight = 6;
                
                // Paredes exteriores
                const walls = [
                    { pos: [0, wallHeight/2, -90], size: [180, wallHeight, 1] },
                    { pos: [0, wallHeight/2, 90], size: [180, wallHeight, 1] },
                    { pos: [-90, wallHeight/2, 0], size: [1, wallHeight, 180] },
                    { pos: [90, wallHeight/2, 0], size: [1, wallHeight, 180] }
                ];

                walls.forEach(wall => {
                    const wallMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(...wall.size),
                        wallMaterial
                    );
                    wallMesh.position.set(...wall.pos);
                    wallMesh.castShadow = true;
                    wallMesh.receiveShadow = true;
                    this.scene.add(wallMesh);
                });

                // Paredes internas - pasillos
                this.createCorridorWalls();
            }

            createCorridorWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                const wallHeight = 6;
                
                // Pasillo principal horizontal
                const corridorWalls = [
                    { pos: [-80, wallHeight/2, -10], size: [20, wallHeight, 0.5] },
                    { pos: [-80, wallHeight/2, 10], size: [20, wallHeight, 0.5] },
                    { pos: [80, wallHeight/2, -10], size: [20, wallHeight, 0.5] },
                    { pos: [80, wallHeight/2, 10], size: [20, wallHeight, 0.5] },
                    
                    // Pasillo vertical
                    { pos: [-10, wallHeight/2, -80], size: [0.5, wallHeight, 20] },
                    { pos: [10, wallHeight/2, -80], size: [0.5, wallHeight, 20] },
                    { pos: [-10, wallHeight/2, 80], size: [0.5, wallHeight, 20] },
                    { pos: [10, wallHeight/2, 80], size: [0.5, wallHeight, 20] }
                ];

                corridorWalls.forEach(wall => {
                    const wallMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(...wall.size),
                        wallMaterial
                    );
                    wallMesh.position.set(...wall.pos);
                    wallMesh.castShadow = true;
                    this.scene.add(wallMesh);
                });
            }

            createRooms() {
                const roomWallMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const wallHeight = 6;

                // Habitaciones del lado izquierdo
                for (let i = 0; i < 6; i++) {
                    const z = -70 + i * 25;
                    
                    const roomWalls = [
                        { pos: [-55, wallHeight/2, z], size: [30, wallHeight, 0.5] },
                        { pos: [-55, wallHeight/2, z + 20], size: [30, wallHeight, 0.5] },
                        { pos: [-70, wallHeight/2, z + 10], size: [0.5, wallHeight, 20] }
                    ];

                    roomWalls.forEach(wall => {
                        const wallMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(...wall.size),
                            roomWallMaterial
                        );
                        wallMesh.position.set(...wall.pos);
                        wallMesh.castShadow = true;
                        this.scene.add(wallMesh);
                    });

                    // Mobiliario
                    this.createRustyBed(-60, z + 5);
                    this.createOldChair(-50, z + 15);
                }

                // Habitaciones del lado derecho
                for (let i = 0; i < 6; i++) {
                    const z = -70 + i * 25;
                    
                    const roomWalls = [
                        { pos: [55, wallHeight/2, z], size: [30, wallHeight, 0.5] },
                        { pos: [55, wallHeight/2, z + 20], size: [30, wallHeight, 0.5] },
                        { pos: [70, wallHeight/2, z + 10], size: [0.5, wallHeight, 20] }
                    ];

                    roomWalls.forEach(wall => {
                        const wallMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(...wall.size),
                            roomWallMaterial
                        );
                        wallMesh.position.set(...wall.pos);
                        wallMesh.castShadow = true;
                        this.scene.add(wallMesh);
                    });

                    this.createRustyBed(60, z + 5);
                    this.createOldChair(50, z + 15);
                }
            }

            createFurniture() {
                // Laboratorio
                this.createLabTable(-30, 40);
                this.createLabTable(-30, 60);
                
                // QuirÃ³fano
                this.createSurgeryTable(30, 40);
                this.createSurgeryTable(30, 60);
                
                // Equipo mÃ©dico disperso
                this.createMedicalCart(0, 50);
                this.createWheelchair(20, 30);
            }

            createStaircase() {
                const stairMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                
                // Escaleras
                for (let i = 0; i < 20; i++) {
                    const step = new THREE.Mesh(
                        new THREE.BoxGeometry(8, 0.4, 1.2),
                        stairMaterial
                    );
                    step.position.set(0, i * 0.4, 25 - i * 0.3);
                    step.castShadow = true;
                    step.receiveShadow = true;
                    this.scene.add(step);
                }

                // Segundo piso
                const secondFloorGeometry = new THREE.PlaneGeometry(160, 160);
                const secondFloorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x222222
                });
                const secondFloor = new THREE.Mesh(secondFloorGeometry, secondFloorMaterial);
                secondFloor.rotation.x = -Math.PI / 2;
                secondFloor.position.y = 8;
                secondFloor.receiveShadow = true;
                this.scene.add(secondFloor);

                // Habitaciones segundo piso
                this.createSecondFloorRooms();
            }

            createSecondFloorRooms() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const wallHeight = 6;
                const yOffset = 8;

                for (let i = 0; i < 8; i++) {
                    const x = -60 + (i % 4) * 30;
                    const z = -50 + Math.floor(i / 4) * 40;
                    
                    const roomWalls = [
                        { pos: [x, yOffset + wallHeight/2, z], size: [25, wallHeight, 0.5] },
                        { pos: [x, yOffset + wallHeight/2, z + 25], size: [25, wallHeight, 0.5] },
                        { pos: [x - 12.5, yOffset + wallHeight/2, z + 12.5], size: [0.5, wallHeight, 25] },
                        { pos: [x + 12.5, yOffset + wallHeight/2, z + 12.5], size: [0.5, wallHeight, 25] }
                    ];

                    roomWalls.forEach(wall => {
                        const wallMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(...wall.size),
                            wallMaterial
                        );
                        wallMesh.position.set(...wall.pos);
                        wallMesh.castShadow = true;
                        this.scene.add(wallMesh);
                    });

                    this.createRustyBed(x, z + 5, yOffset);
                    this.createOldChair(x + 8, z + 15, yOffset);
                }
            }

            // Funciones de mobiliario

            createRustyBed(x, z, yOffset = 0) {
                const bedMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                
                const bedFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.8, 4.5),
                    bedMaterial
                );
                bedFrame.position.set(x, yOffset + 0.4, z);
                bedFrame.castShadow = true;
                this.scene.add(bedFrame);

                const mattress = new THREE.Mesh(
                    new THREE.BoxGeometry(2.2, 0.4, 4.2),
                    new THREE.MeshLambertMaterial({ color: 0x4a4a4a })
                );
                mattress.position.set(x, yOffset + 1, z);
                mattress.castShadow = true;
                this.scene.add(mattress);
            }

            createOldChair(x, z, yOffset = 0) {
                const chairMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
                
                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 0.2, 1),
                    chairMaterial
                );
                seat.position.set(x, yOffset + 1, z);
                seat.castShadow = true;
                this.scene.add(seat);

                const backrest = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1.5, 0.2),
                    chairMaterial
                );
                backrest.position.set(x, yOffset + 1.6, z - 0.4);
                backrest.castShadow = true;
                this.scene.add(backrest);
            }

            createLabTable(x, z, yOffset = 0) {
                const tableMaterial = new THREE.MeshLambertMaterial({ color: 0x777777 });
                
                const table = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 0.3, 1.5),
                    tableMaterial
                );
                table.position.set(x, yOffset + 1.2, z);
                table.castShadow = true;
                this.scene.add(table);

                // QuÃ­micos derramados
                for (let i = 0; i < 3; i++) {
                    const spill = new THREE.Mesh(
                        new THREE.CircleGeometry(0.3, 8),
                        new THREE.MeshLambertMaterial({ 
                            color: [0x00ff00, 0xff0000, 0x0000ff][i],
                            transparent: true,
                            opacity: 0.7
                        })
                    );
                    spill.rotation.x = -Math.PI / 2;
                    spill.position.set(x + (i - 1) * 0.8, yOffset + 1.51, z);
                    this.scene.add(spill);
                }
            }

            createSurgeryTable(x, z, yOffset = 0) {
                const tableMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                
                const table = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.4, 5),
                    tableMaterial
                );
                table.position.set(x, yOffset + 1.2, z);
                table.castShadow = true;
                this.scene.add(table);

                // Manchas de sangre
                const bloodStain = new THREE.Mesh(
                    new THREE.CircleGeometry(0.8, 8),
                    new THREE.MeshLambertMaterial({ color: 0x8b0000 })
                );
                bloodStain.rotation.x = -Math.PI / 2;
                bloodStain.position.set(x, yOffset + 1.41, z);
                this.scene.add(bloodStain);
            }

            createMedicalCart(x, z, yOffset = 0) {
                const cartMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                
                const cart = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 1.2, 1),
                    cartMaterial
                );
                cart.position.set(x, yOffset + 0.6, z);
                cart.castShadow = true;
                this.scene.add(cart);
            }

            createWheelchair(x, z, yOffset = 0) {
                const chairMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
                
                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 0.15, 1.2),
                    chairMaterial
                );
                seat.position.set(x, yOffset + 1, z);
                seat.castShadow = true;
                this.scene.add(seat);

                const backrest = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 1.8, 0.15),
                    chairMaterial
                );
                backrest.position.set(x, yOffset + 1.8, z - 0.5);
                backrest.castShadow = true;
                this.scene.add(backrest);

                // Ruedas
                for (let i = 0; i < 4; i++) {
                    const wheel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.25, 0.25, 0.1),
                        new THREE.MeshLambertMaterial({ color: 0x333333 })
                    );
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(
                        x + (i % 2 === 0 ? -0.5 : 0.5), 
                        yOffset + 0.25, 
                        z + (i < 2 ? -0.4 : 0.4)
                    );
                    wheel.castShadow = true;
                    this.scene.add(wheel);
                }
            }

            createBloodStains() {
                const bloodMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8b0000,
                    transparent: true,
                    opacity: 0.8
                });

                for (let i = 0; i < 30; i++) {
                    const x = -80 + Math.random() * 160;
                    const z = -80 + Math.random() * 160;
                    const size = 0.3 + Math.random() * 1.2;

                    const bloodStain = new THREE.Mesh(
                        new THREE.CircleGeometry(size, 8),
                        bloodMaterial
                    );
                    bloodStain.rotation.x = -Math.PI / 2;
                    bloodStain.position.set(x, 0.01, z);
                    this.scene.add(bloodStain);
                }
            }

            createLighting() {
                // Luz ambiental muy tenue
                const ambientLight = new THREE.AmbientLight(0x404040, 0.1);
                this.scene.add(ambientLight);

                // Luces parpadeantes
                this.createFlickeringLights();

                // Linterna
                this.flashlight.light = new THREE.SpotLight(0xffffff, 3, 40, Math.PI / 3, 0.3);
                this.flashlight.light.position.copy(this.camera.position);
                this.flashlight.light.target.position.set(0, 0, -1);
                this.flashlight.light.castShadow = true;
                this.flashlight.light.shadow.mapSize.width = 2048;
                this.flashlight.light.shadow.mapSize.height = 2048;
                this.scene.add(this.flashlight.light);
                this.scene.add(this.flashlight.light.target);
            }

            createFlickeringLights() {
                const lightPositions = [
                    [-40, 5.5, -40], [0, 5.5, -40], [40, 5.5, -40],
                    [-40, 5.5, 0], [0, 5.5, 0], [40, 5.5, 0],
                    [-40, 5.5, 40], [0, 5.5, 40], [40, 5.5, 40],
                    [-40, 13.5, -40], [0, 13.5, -40], [40, 13.5, -40],
                    [-40, 13.5, 0], [0, 13.5, 0], [40, 13.5, 0]
                ];
                
                lightPositions.forEach(pos => {
                    const light = new THREE.PointLight(0xffffaa, 0.3, 25);
                    light.position.set(...pos);
                    light.castShadow = true;
                    
                    light.userData = {
                        originalIntensity: 0.3,
                        flickerTime: Math.random() * 1000,
                        broken: Math.random() < 0.2
                    };
                    
                    this.scene.add(light);
                });
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key.toLowerCase() === ' ') {
                        e.preventDefault();
                        this.toggleFlashlight();
                    }
                    if (e.key.toLowerCase() === 'e') {
                        this.useStairs();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                document.addEventListener('click', () => {
                    this.toggleFlashlight();
                    if (!this.isMobile) {
                        document.body.requestPointerLock();
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === document.body && !this.isMobile) {
                        this.yaw -= (e.movementX || 0) * this.sensitivity;
                        this.pitch -= (e.movementY || 0) * this.sensitivity;
                        this.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.pitch));
                    }
                });

                if (this.isMobile) {
                    this.setupMobileControls();
                }

                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restart();
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setupMobileControls() {
                const joystickElement = document.getElementById('joystick');
                const joystickKnob = document.getElementById('joystickKnob');
                const flashlightBtn = document.getElementById('flashlightBtn');
                const useBtn = document.getElementById('useBtn');

                joystickElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.joystick.active = true;
                    const rect = joystickElement.getBoundingClientRect();
                    this.joystick.startX = rect.left + rect.width / 2;
                    this.joystick.startY = rect.top + rect.height / 2;
                });

                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    
                    if (this.joystick.active && e.touches.length > 0) {
                        const touch = e.touches[0];
                        const deltaX = touch.clientX - this.joystick.startX;
                        const deltaY = touch.clientY - this.joystick.startY;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        const maxDistance = 30;
                        
                        if (distance <= maxDistance) {
                            this.joystick.currentX = deltaX / maxDistance;
                            this.joystick.currentY = deltaY / maxDistance;
                            joystickKnob.style.transform = `translate(-50%, -50%) translate(${deltaX}px, ${deltaY}px)`;
                        }
                    }
                    
                    if (e.touches.length > 1 || (!this.joystick.active && e.touches.length === 1)) {
                        const touch = e.touches[this.joystick.active ? 1 : 0];
                        if (this.touchLook.active) {
                            const deltaX = touch.clientX - this.touchLook.lastX;
                            const deltaY = touch.clientY - this.touchLook.lastY;
                            
                            this.yaw -= deltaX * this.sensitivity;
                            this.pitch -= deltaY * this.sensitivity;
                            this.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.pitch));
                        }
                        this.touchLook.active = true;
                        this.touchLook.lastX = touch.clientX;
                        this.touchLook.lastY = touch.clientY;
                    }
                });

                document.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.joystick.active = false;
                    this.joystick.currentX = 0;
                    this.joystick.currentY = 0;
                    this.touchLook.active = false;
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                });

                flashlightBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.toggleFlashlight();
                });

                useBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.useStairs();
                });
            }

            updatePlayer() {
                if (this.gameOver) return;

                const moveSpeed = this.player.speed;
                let newX = this.player.x;
                let newZ = this.player.z;

                const forward = new THREE.Vector3(0, 0, -1);
                const right = new THREE.Vector3(1, 0, 0);
                
                forward.applyEuler(new THREE.Euler(0, this.yaw, 0));
                right.applyEuler(new THREE.Euler(0, this.yaw, 0));

                if (this.keys['w']) {
                    newX += forward.x * moveSpeed;
                    newZ += forward.z * moveSpeed;
                }
                if (this.keys['s']) {
                    newX -= forward.x * moveSpeed;
                    newZ -= forward.z * moveSpeed;
                }
                if (this.keys['a']) {
                    newX -= right.x * moveSpeed;
                    newZ -= right.z * moveSpeed;
                }
                if (this.keys['d']) {
                    newX += right.x * moveSpeed;
                    newZ += right.z * moveSpeed;
                }

                if (this.isMobile && (this.joystick.currentX !== 0 || this.joystick.currentY !== 0)) {
                    newX += (forward.x * -this.joystick.currentY + right.x * this.joystick.currentX) * moveSpeed;
                    newZ += (forward.z * -this.joystick.currentY + right.z * this.joystick.currentX) * moveSpeed;
                }

                if (newX > -85 && newX < 85 && newZ > -85 && newZ < 85) {
                    this.player.x = newX;
                    this.player.z = newZ;
                }

                const stairDistance = Math.sqrt(Math.pow(this.player.x - 0, 2) + Math.pow(this.player.z - 25, 2));
                this.nearStairs = stairDistance < 5;

                this.camera.position.set(this.player.x, this.player.y + (this.player.currentFloor * 8), this.player.z);
                this.camera.rotation.set(this.pitch, this.yaw, 0);

                if (this.flashlight.light) {
                    this.flashlight.light.position.copy(this.camera.position);
                    
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyEuler(new THREE.Euler(this.pitch, this.yaw, 0));
                    this.flashlight.light.target.position.copy(this.camera.position).add(direction);
                }

                if (this.flashlight.on && this.flashlight.battery > 0) {
                    this.flashlight.battery -= this.flashlight.drainRate;
                    this.updateBatteryDisplay();
                    
                    if (this.flashlight.battery <= 0) {
                        this.flashlight.battery = 0;
                        this.flashlight.light.intensity = 0;
                    }
                }
            }

            useStairs() {
                if (this.nearStairs) {
                    this.player.currentFloor = this.player.currentFloor === 0 ? 1 : 0;
                    this.player.y = 1.7 + (this.player.currentFloor * 8);
                    
                    document.getElementById('currentFloor').textContent = 
                        this.player.currentFloor === 0 ? 'Planta Baja' : 'Primer Piso';
                    
                    this.player.z += this.player.currentFloor === 0 ? -10 : 10;
                }
            }

            toggleFlashlight() {
                if (this.flashlight.battery > 0) {
                    this.flashlight.on = !this.flashlight.on;
                    if (this.flashlight.light) {
                        this.flashlight.light.intensity = this.flashlight.on ? 3 : 0;
                    }
                }
            }

            updateBatteryDisplay() {
                const batteryLevel = document.getElementById('batteryLevel');
                const batteryPercent = document.getElementById('batteryPercent');
                
                batteryLevel.style.width = `${Math.max(0, this.flashlight.battery)}%`;
                batteryPercent.textContent = `${Math.round(Math.max(0, this.flashlight.battery))}%`;
                
                if (this.flashlight.battery < 25) {
                    batteryLevel.style.background = '#F44336';
                } else if (this.flashlight.battery < 50) {
                    batteryLevel.style.background = '#FFC107';
                } else {
                    batteryLevel.style.background = '#4CAF50';
                }
            }

            startParanormalEvents() {
                setInterval(() => {
                    if (this.gameOver) return;
                    this.triggerParanormalEvent();
                }, 10000 + Math.random() * 15000);
            }

            triggerParanormalEvent() {
                const eventType = Math.random();
                
                if (eventType < 0.4) {
                    this.scene.children.forEach(child => {
                        if (child.type === 'PointLight' && child.userData.originalIntensity) {
                            const originalIntensity = child.userData.originalIntensity;
                            child.intensity = Math.random() * originalIntensity * 0.3;
                            setTimeout(() => {
                                child.intensity = child.userData.broken ? 0 : originalIntensity;
                            }, 500 + Math.random() * 1000);
                        }
                    });
                } else if (eventType < 0.6) {
                    this.flashlight.battery = Math.max(0, this.flashlight.battery - 5);
                    this.updateBatteryDisplay();
                } else if (eventType < 0.8) {
                    this.addMovingShadow();
                } else {
                    this.triggerJumpscare();
                }
            }

            addMovingShadow() {
                const shadowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.7
                });
                
                const shadow = new THREE.Mesh(
                    new THREE.PlaneGeometry(2, 4),
                    shadowMaterial
                );
                
                shadow.position.set(
                    -70 + Math.random() * 140,
                    2 + (this.player.currentFloor * 8),
                    -70 + Math.random() * 140
                );
                shadow.lookAt(this.camera.position);
                
                this.scene.add(shadow);
                
                setTimeout(() => {
                    this.scene.remove(shadow);
                }, 3000 + Math.random() * 2000);
            }

            triggerJumpscare() {
                const flash = document.createElement('div');
                flash.style.position = 'fixed';
                flash.style.top = '0';
                flash.style.left = '0';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                flash.style.zIndex = '1000';
                flash.style.pointerEvents = 'none';
                document.body.appendChild(flash);
                
                setTimeout(() => {
                    document.body.removeChild(flash);
                }, 200);

                this.flashlight.battery = Math.max(0, this.flashlight.battery - 3);
                this.updateBatteryDisplay();
            }

            gameLoop() {
                this.updatePlayer();
                this.timeElapsed++;
                
                this.scene.children.forEach(child => {
                    if (child.type === 'PointLight' && child.userData.flickerTime !== undefined) {
                        child.userData.flickerTime += 16;
                        if (child.userData.flickerTime > 2000 + Math.random() * 3000) {
                            if (!child.userData.broken) {
                                child.intensity = Math.random() * child.userData.originalIntensity;
                                child.userData.flickerTime = 0;
                            }
                        }
                    }
                });
                
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.gameLoop());
            }

            restart() {
                this.gameOver = false;
                this.player.x = 0;
                this.player.z = 0;
                this.player.currentFloor = 0;
                this.player.y = 1.7;
                this.flashlight.battery = 100;
                this.flashlight.on = true;
                this.yaw = 0;
                this.pitch = 0;
                
                this.updateBatteryDisplay();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('currentFloor').textContent = 'Planta Baja';
                
                if (this.flashlight.light) {
                    this.flashlight.light.intensity = 3;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const game = new HorrorGame3D();
        });
    </script>
</body>
</html>