<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hospital Abandonado 3D - Juego de Terror</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            cursor: none;
            touch-action: none;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #flashlightBattery {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .battery-icon {
            font-size: 20px;
        }

        .battery-bar {
            width: 100px;
            height: 15px;
            border: 2px solid #666;
            border-radius: 3px;
            background: #222;
            overflow: hidden;
        }

        .battery-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #F44336);
            transition: width 0.3s ease;
            width: 100%;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #888;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        #mobileControls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            pointer-events: auto;
        }

        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
            
            #instructions {
                font-size: 10px;
                bottom: 80px;
            }
        }

        .mobile-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 15px;
            margin: 5px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }

        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        #joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
            pointer-events: auto;
        }

        @media (max-width: 768px) {
            #joystick {
                display: block;
            }
        }

        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #ff4444;
            padding: 40px;
            border: 3px solid #666;
            text-align: center;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: auto;
        }

        #gameOverScreen h1 {
            margin-bottom: 20px;
            animation: flicker 0.5s infinite alternate;
        }

        #restartBtn {
            background: #333;
            color: #fff;
            border: 2px solid #666;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        #restartBtn:hover {
            background: #555;
            border-color: #888;
        }

        .hidden {
            display: none !important;
        }

        @keyframes flicker {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            font-size: 20px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #floorIndicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div id="flashlightBattery">
                <div class="battery-icon">üîã</div>
                <div class="battery-bar">
                    <div id="batteryLevel" class="battery-fill"></div>
                </div>
                <span id="batteryPercent">100%</span>
            </div>
            
            <div id="floorIndicator">
                <span id="currentFloor">Planta Baja</span>
            </div>
            
            <div id="instructions">
                PC: WASD - Mover | Mouse - Mirar | Click/Espacio - Linterna<br>
                M√≥vil: Joystick - Mover | Tocar pantalla - Mirar | Bot√≥n - Linterna<br>
                E - Usar escaleras
            </div>
            <div id="crosshair">‚úö</div>
            
            <!-- Mobile controls -->
            <div id="joystick">
                <div id="joystickKnob"></div>
            </div>
            <div id="mobileControls">
                <button class="mobile-btn" id="flashlightBtn">üí°</button>
                <button class="mobile-btn" id="useBtn">E</button>
            </div>
            
            <div id="gameOverScreen" class="hidden">
                <h1>LA OSCURIDAD TE CONSUME...</h1>
                <button id="restartBtn">Reintentar</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class HorrorGame3D {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFShadowMap;
                this.renderer.setClearColor(0x000000);
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);

                // Player properties
                this.player = {
                    x: 0,
                    y: 1.7,
                    z: 0,
                    speed: 0.15,
                    height: 1.7,
                    currentFloor: 0 // 0 = planta baja, 1 = primer piso
                };

                // Movement and rotation
                this.keys = {};
                this.yaw = 0;
                this.pitch = 0;
                this.sensitivity = 0.002;

                // Mobile controls
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.joystick = {
                    active: false,
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0
                };
                this.touchLook = {
                    active: false,
                    lastX: 0,
                    lastY: 0
                };

                // Flashlight properties - Bater√≠a m√°s duradera
                this.flashlight = {
                    on: true,
                    battery: 100,
                    drainRate: 0.008, // Reducido significativamente
                    light: null
                };

                // Game state
                this.gameOver = false;
                this.timeElapsed = 0;
                this.paranormalEvents = [];
                this.nearStairs = false;

                // Hospital layouts for both floors
                this.floors = {
                    0: [], // Ground floor objects
                    1: []  // First floor objects
                };

                this.init();
            }

            init() {
                this.setupCamera();
                this.createHospital();
                this.createLighting();
                this.setupControls();
                this.gameLoop();
                this.startParanormalEvents();
            }

            setupCamera() {
                this.camera.position.set(this.player.x, this.player.y, this.player.z);
                this.camera.rotation.order = 'YXZ';
            }

            createHospital() {
                // Suelo m√°s grande y deteriorado
                const floorGeometry = new THREE.PlaneGeometry(200, 200);
                const floorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x0f0f0f,
                    transparent: true,
                    opacity: 0.9
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);

                // Crear ambos pisos
                this.createGroundFloor();
                this.createFirstFloor();
                this.createStaircase();
            }

            createGroundFloor() {
                this.createExteriorWalls();
                this.createMainCorridors();
                this.createPatientRooms();
                this.createEmergencyRoom();
                this.createMorgue();
                this.createLaboratory();
                this.createOldEquipment();
                this.createBloodStains();
                this.createDebris();
            }

            createFirstFloor() {
                const yOffset = 8; // Altura del segundo piso
                
                // Suelo del segundo piso
                const secondFloorGeometry = new THREE.PlaneGeometry(180, 180);
                const secondFloorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x1a1a1a,
                    transparent: true,
                    opacity: 0.95
                });
                const secondFloor = new THREE.Mesh(secondFloorGeometry, secondFloorMaterial);
                secondFloor.rotation.x = -Math.PI / 2;
                secondFloor.position.y = yOffset;
                secondFloor.receiveShadow = true;
                this.scene.add(secondFloor);

                this.createSecondFloorRooms(yOffset);
                this.createOperatingRooms(yOffset);
                this.createPsychiatricWing(yOffset);
                this.createAbandonedOffices(yOffset);
            }

            createExteriorWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const wallHeight = 6;
                const wallThickness = 1;
                const buildingSize = 90;
                
                // Paredes exteriores deterioradas
                const walls = [
                    { pos: [0, wallHeight/2, -buildingSize], size: [buildingSize*2, wallHeight, wallThickness] },
                    { pos: [0, wallHeight/2, buildingSize], size: [buildingSize*2, wallHeight, wallThickness] },
                    { pos: [-buildingSize, wallHeight/2, 0], size: [wallThickness, wallHeight, buildingSize*2] },
                    { pos: [buildingSize, wallHeight/2, 0], size: [wallThickness, wallHeight, buildingSize*2] }
                ];

                walls.forEach(wall => {
                    const wallMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(...wall.size),
                        wallMaterial
                    );
                    wallMesh.position.set(...wall.pos);
                    wallMesh.castShadow = true;
                    wallMesh.receiveShadow = true;
                    this.scene.add(wallMesh);
                });
            }

            createMainCorridors() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                const wallHeight = 6;
                const wallThickness = 0.8;

                // Pasillo principal horizontal
                const mainCorridorWalls = [
                    { pos: [-80, wallHeight/2, -10], size: [20, wallHeight, wallThickness] },
                    { pos: [-80, wallHeight/2, 10], size: [20, wallHeight, wallThickness] },
                    { pos: [80, wallHeight/2, -10], size: [20, wallHeight, wallThickness] },
                    { pos: [80, wallHeight/2, 10], size: [20, wallHeight, wallThickness] }
                ];

                // Pasillo principal vertical
                const verticalCorridorWalls = [
                    { pos: [-10, wallHeight/2, -80], size: [wallThickness, wallHeight, 20] },
                    { pos: [10, wallHeight/2, -80], size: [wallThickness, wallHeight, 20] },
                    { pos: [-10, wallHeight/2, 80], size: [wallThickness, wallHeight, 20] },
                    { pos: [10, wallHeight/2, 80], size: [wallThickness, wallHeight, 20] }
                ];

                [...mainCorridorWalls, ...verticalCorridorWalls].forEach(wall => {
                    const wallMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(...wall.size),
                        wallMaterial
                    );
                    wallMesh.position.set(...wall.pos);
                    wallMesh.castShadow = true;
                    this.scene.add(wallMesh);
                });
            }

            createPatientRooms() {
                const roomWallMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const wallHeight = 6;
                const wallThickness = 0.5;

                // Habitaciones del lado izquierdo
                for (let i = 0; i < 8; i++) {
                    const z = -70 + i * 18;
                    
                    // Paredes de la habitaci√≥n
                    const roomWalls = [
                        { pos: [-55, wallHeight/2, z], size: [30, wallHeight, wallThickness] },
                        { pos: [-55, wallHeight/2, z + 15], size: [30, wallHeight, wallThickness] },
                        { pos: [-70, wallHeight/2, z + 7.5], size: [wallThickness, wallHeight, 15] }
                    ];

                    roomWalls.forEach(wall => {
                        const wallMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(...wall.size),
                            roomWallMaterial
                        );
                        wallMesh.position.set(...wall.pos);
                        wallMesh.castShadow = true;
                        this.scene.add(wallMesh);
                    });

                    // Mobiliario deteriorado
                    this.createRustyBed(-60, z + 5);
                    this.createBrokenNightstand(-50, z + 10);
                    this.createOldChair(-65, z + 2);
                }

                // Habitaciones del lado derecho
                for (let i = 0; i < 8; i++) {
                    const z = -70 + i * 18;
                    
                    const roomWalls = [
                        { pos: [55, wallHeight/2, z], size: [30, wallHeight, wallThickness] },
                        { pos: [55, wallHeight/2, z + 15], size: [30, wallHeight, wallThickness] },
                        { pos: [70, wallHeight/2, z + 7.5], size: [wallThickness, wallHeight, 15] }
                    ];

                    roomWalls.forEach(wall => {
                        const wallMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(...wall.size),
                            roomWallMaterial
                        );
                        wallMesh.position.set(...wall.pos);
                        wallMesh.castShadow = true;
                        this.scene.add(wallMesh);
                    });

                    this.createRustyBed(60, z + 5);
                    this.createBrokenNightstand(50, z + 10);
                    this.createOldChair(65, z + 2);
                }
            }

            createEmergencyRoom() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                const wallHeight = 6;
                
                // Sala de emergencias grande
                const emergencyWalls = [
                    { pos: [-40, wallHeight/2, -40], size: [40, wallHeight, 0.5] },
                    { pos: [-40, wallHeight/2, -20], size: [40, wallHeight, 0.5] },
                    { pos: [-60, wallHeight/2, -30], size: [0.5, wallHeight, 20] },
                    { pos: [-20, wallHeight/2, -30], size: [0.5, wallHeight, 20] }
                ];

                emergencyWalls.forEach(wall => {
                    const wallMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(...wall.size),
                        wallMaterial
                    );
                    wallMesh.position.set(...wall.pos);
                    wallMesh.castShadow = true;
                    this.scene.add(wallMesh);
                });

                // Camillas ensangrentadas
                for (let i = 0; i < 3; i++) {
                    this.createBloodySurgeryTable(-50 + i * 10, -30);
                }

                // Equipo m√©dico oxidado
                this.createRustyMedicalCart(-35, -25);
                this.createOldDefibrillator(-45, -35);
            }

            createMorgue() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const wallHeight = 6;
                
                // Morgue en el s√≥tano (visualmente)
                const morgueWalls = [
                    { pos: [40, wallHeight/2, -40], size: [40, wallHeight, 0.5] },
                    { pos: [40, wallHeight/2, -20], size: [40, wallHeight, 0.5] },
                    { pos: [20, wallHeight/2, -30], size: [0.5, wallHeight, 20] },
                    { pos: [60, wallHeight/2, -30], size: [0.5, wallHeight, 20] }
                ];

                morgueWalls.forEach(wall => {
                    const wallMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(...wall.size),
                        wallMaterial
                    );
                    wallMesh.position.set(...wall.pos);
                    wallMesh.castShadow = true;
                    this.scene.add(wallMesh);
                });

                // Mesas de autopsias
                for (let i = 0; i < 4; i++) {
                    this.createAutopsyTable(30 + i * 8, -35 + (i % 2) * 10);
                }

                // Refrigeradores para cad√°veres
                this.createMorgueRefrigerators(25, -25);
            }

            createLaboratory() {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                const wallHeight = 6;
                
                // Laboratorio grande
                const labWalls = [
                    { pos: [-40, wallHeight/2, 40], size: [50, wallHeight, 0.5] },
                    { pos: [-40, wallHeight/2, 70], size: [50, wallHeight, 0.5] },
                    { pos: [-65, wallHeight/2, 55], size: [0.5, wallHeight, 30] },
                    { pos: [-15, wallHeight/2, 55], size: [0.5, wallHeight, 30] }
                ];

                labWalls.forEach(wall => {
                    const wallMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(...wall.size),
                        wallMaterial
                    );
                    wallMesh.position.set(...wall.pos);
                    wallMesh.castShadow = true;
                    this.scene.add(wallMesh);
                });

                // Mesas de laboratorio con qu√≠micos derramados
                for (let i = 0; i < 4; i++) {
                    this.createLabTable(-55 + i * 10, 50 + (i % 2) * 10);
                    this.createSpilledChemicals(-55 + i * 10, 52 + (i % 2) * 10);
                }

                // Microscopios rotos
                this.createBrokenMicroscope(-30, 45);
                this.createBrokenMicroscope(-50, 65);
            }

            createStaircase() {
                const stairMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                
                // Escaleras principales
                for (let i = 0; i < 16; i++) {
                    const step = new THREE.Mesh(
                        new THREE.BoxGeometry(8, 0.3, 1.2),
                        stairMaterial
                    );
                    step.position.set(0, i * 0.5, 30 - i * 0.3);
                    step.castShadow = true;
                    step.receiveShadow = true;
                    this.scene.add(step);
                }

                // Pasamanos oxidados
                const handrailMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                const leftHandrail = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 1, 10),
                    handrailMaterial
                );
                leftHandrail.position.set(-3.5, 4, 25);
                leftHandrail.castShadow = true;
                this.scene.add(leftHandrail);

                const rightHandrail = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 1, 10),
                    handrailMaterial
                );
                rightHandrail.position.set(3.5, 4, 25);
                rightHandrail.castShadow = true;
                this.scene.add(rightHandrail);
            }

            createSecondFloorRooms(yOffset) {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const wallHeight = 6;

                // M√°s habitaciones en el segundo piso
                for (let i = 0; i < 10; i++) {
                    const x = -70 + (i % 5) * 28;
                    const z = -60 + Math.floor(i / 5) * 40;
                    
                    // Paredes de habitaci√≥n
                    const roomWalls = [
                        { pos: [x, yOffset + wallHeight/2, z], size: [25, wallHeight, 0.5] },
                        { pos: [x, yOffset + wallHeight/2, z + 20], size: [25, wallHeight, 0.5] },
                        { pos: [x - 12.5, yOffset + wallHeight/2, z + 10], size: [0.5, wallHeight, 20] },
                        { pos: [x + 12.5, yOffset + wallHeight/2, z + 10], size: [0.5, wallHeight, 20] }
                    ];

                    roomWalls.forEach(wall => {
                        const wallMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(...wall.size),
                            wallMaterial
                        );
                        wallMesh.position.set(...wall.pos);
                        wallMesh.castShadow = true;
                        this.scene.add(wallMesh);
                    });

                    // Mobiliario del segundo piso
                    this.createRustyBed(x, z + 5, yOffset);
                    this.createOldWheelchair(x + 8, z + 12, yOffset);
                }
            }

            createOperatingRooms(yOffset) {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                const wallHeight = 6;

                // Quir√≥fanos principales
                for (let i = 0; i < 3; i++) {
                    const x = -20 + i * 20;
                    const z = 40;
                    
                    const roomWalls = [
                        { pos: [x, yOffset + wallHeight/2, z], size: [18, wallHeight, 0.5] },
                        { pos: [x, yOffset + wallHeight/2, z + 25], size: [18, wallHeight, 0.5] },
                        { pos: [x - 9, yOffset + wallHeight/2, z + 12.5], size: [0.5, wallHeight, 25] },
                        { pos: [x + 9, yOffset + wallHeight/2, z + 12.5], size: [0.5, wallHeight, 25] }
                    ];

                    roomWalls.forEach(wall => {
                        const wallMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(...wall.size),
                            wallMaterial
                        );
                        wallMesh.position.set(...wall.pos);
                        wallMesh.castShadow = true;
                        this.scene.add(wallMesh);
                    });

                    // Mesas de operaciones ensangrentadas
                    this.createBloodySurgeryTable(x, z + 12, yOffset);
                    this.createSurgicalLamps(x, z + 15, yOffset);
                }
            }

            createPsychiatricWing(yOffset) {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const wallHeight = 6;

                // Ala psiqui√°trica - m√°s siniestra
                const psychWalls = [
                    { pos: [60, yOffset + wallHeight/2, -30], size: [30, wallHeight, 0.5] },
                    { pos: [60, yOffset + wallHeight/2, 30], size: [30, wallHeight, 0.5] },
                    { pos: [45, yOffset + wallHeight/2, 0], size: [0.5, wallHeight, 60] },
                    { pos: [75, yOffset + wallHeight/2, 0], size: [0.5, wallHeight, 60] }
                ];

                psychWalls.forEach(wall => {
                    const wallMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(...wall.size),
                        wallMaterial
                    );
                    wallMesh.position.set(...wall.pos);
                    wallMesh.castShadow = true;
                    this.scene.add(wallMesh);
                });

                // Celdas acolchadas
                for (let i = 0; i < 6; i++) {
                    this.createPaddedCell(50 + (i % 2) * 12, -20 + (i % 3) * 15, yOffset);
                }

                // Sillas de electroshock
                this.createElectroshockChair(65, -10, yOffset);
                this.createElectroshockChair(65, 10, yOffset);
            }

            createAbandonedOffices(yOffset) {
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const wallHeight = 6;

                // Oficinas abandonadas
                for (let i = 0; i < 4; i++) {
                    const x = -60 + i * 15;
                    const z = -40;
                    
                    const officeWalls = [
                        { pos: [x, yOffset + wallHeight/2, z], size: [12, wallHeight, 0.5] },
                        { pos: [x, yOffset + wallHeight/2, z + 15], size: [12, wallHeight, 0.5] },
                        { pos: [x - 6, yOffset + wallHeight/2, z + 7.5], size: [0.5, wallHeight, 15] },
                        { pos: [x + 6, yOffset + wallHeight/2, z + 7.5], size: [0.5, wallHeight, 15] }
                    ];

                    officeWalls.forEach(wall => {
                        const wallMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(...wall.size),
                            wallMaterial
                        );
                        wallMesh.position.set(...wall.pos);
                        wallMesh.castShadow = true;
                        this.scene.add(wallMesh);
                    });

                    // Mobiliario de oficina viejo
                    this.createOldDesk(x, z + 5, yOffset);
                    this.createBrokenComputer(x + 3, z + 8, yOffset);
                }
            }

            // M√©todos para crear objetos espec√≠ficos m√°s detallados y terror√≠ficos

            createRustyBed(x, z, yOffset = 0) {
                const bedMaterial = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
                const rustMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                
                const bedFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.8, 4.5),
                    rustMaterial
                );
                bedFrame.position.set(x, yOffset + 0.4, z);
                bedFrame.castShadow = true;
                this.scene.add(bedFrame);

                const mattress = new THREE.Mesh(
                    new THREE.BoxGeometry(2.2, 0.4, 4.2),
                    bedMaterial
                );
                mattress.position.set(x, yOffset + 1, z);
                mattress.castShadow = true;
                this.scene.add(mattress);

                // Manchas de sangre en el colch√≥n
                const bloodStain = new THREE.Mesh(
                    new THREE.CircleGeometry(0.8, 8),
                    new THREE.MeshLambertMaterial({ color: 0x8b0000 })
                );
                bloodStain.rotation.x = -Math.PI / 2;
                bloodStain.position.set(x, yOffset + 1.21, z);
                this.scene.add(bloodStain);
            }

            createBloodySurgeryTable(x, z, yOffset = 0) {
                const tableMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const surgeryTable = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.4, 5),
                    tableMaterial
                );
                surgeryTable.position.set(x, yOffset + 1.2, z);
                surgeryTable.castShadow = true;
                this.scene.add(surgeryTable);

                // M√∫ltiples manchas de sangre
                for (let i = 0; i < 3; i++) {
                    const bloodStain = new THREE.Mesh(
                        new THREE.CircleGeometry(0.4 + Math.random() * 0.3, 8),
                        new THREE.MeshLambertMaterial({ color: 0x8b0000 })
                    );
                    bloodStain.rotation.x = -Math.PI / 2;
                    bloodStain.position.set(x + (Math.random() - 0.5), yOffset + 1.41, z + (Math.random() - 0.5) * 2);
                    this.scene.add(bloodStain);
                }

                // Instrumentos quir√∫rgicos ensangrentados
                this.createBloodyInstruments(x + 1, z, yOffset);
            }

            createBloodyInstruments(x, z, yOffset = 0) {
                const metalMaterial = new THREE.MeshLambertMaterial({ color: 0x777777 });
                const bloodMaterial = new THREE.MeshLambertMaterial({ color: 0x8b0000 });
                
                // Bistur√≠
                const scalpel = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.05, 1),
                    metalMaterial
                );
                scalpel.position.set(x, yOffset + 1.42, z);
                scalpel.castShadow = true;
                this.scene.add(scalpel);

                // Sierra quir√∫rgica
                const saw = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.1, 1.5),
                    metalMaterial
                );
                saw.position.set(x + 0.3, yOffset + 1.42, z + 0.5);
                saw.castShadow = true;
                this.scene.add(saw);

                // Bandeja con m√°s instrumentos
                const tray = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.1, 1.2),
                    metalMaterial
                );
                tray.position.set(x, yOffset + 1.41, z + 1);
                tray.castShadow = true;
                this.scene.add(tray);
            }

            createOldWheelchair(x, z, yOffset = 0) {
                const chairMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
                const rustMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                
                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 0.15, 1.2),
                    rustMaterial
                );
                seat.position.set(x, yOffset + 1, z);
                seat.castShadow = true;
                this.scene.add(seat);

                const backrest = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 1.8, 0.15),
                    chairMaterial
                );
                backrest.position.set(x, yOffset + 1.8, z - 0.5);
                backrest.castShadow = true;
                this.scene.add(backrest);

                // Ruedas rotas
                for (let i = 0; i < 4; i++) {
                    const wheel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.25, 0.25, 0.1),
                        new THREE.MeshLambertMaterial({ color: 0x333333 })
                    );
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(
                        x + (i % 2 === 0 ? -0.5 : 0.5), 
                        yOffset + 0.25, 
                        z + (i < 2 ? -0.4 : 0.4)
                    );
                    wheel.castShadow = true;
                    this.scene.add(wheel);
                }
            }

            createSpilledChemicals(x, z, yOffset = 0) {
                const colors = [0x00ff00, 0xff0000, 0x0000ff, 0xffff00, 0xff00ff];
                
                for (let i = 0; i < 5; i++) {
                    // Botellas rotas
                    const bottleGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.6);
                    const bottleMaterial = new THREE.MeshLambertMaterial({ 
                        color: colors[i],
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const bottle = new THREE.Mesh(bottleGeometry, bottleMaterial);
                    bottle.position.set(x + i * 0.3, yOffset + 0.3, z);
                    bottle.rotation.z = Math.random() * Math.PI;
                    bottle.castShadow = true;
                    this.scene.add(bottle);

                    // Charcos qu√≠micos
                    const spill = new THREE.Mesh(
                        new THREE.CircleGeometry(0.4 + Math.random() * 0.3, 8),
                        new THREE.MeshLambertMaterial({ 
                            color: colors[i],
                            transparent: true,
                            opacity: 0.6
                        })
                    );
                    spill.rotation.x = -Math.PI / 2;
                    spill.position.set(x + i * 0.3 + (Math.random() - 0.5), yOffset + 0.01, z + (Math.random() - 0.5));
                    this.scene.add(spill);
                }
            }

            createBloodStains() {
                const bloodMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8b0000,
                    transparent: true,
                    opacity: 0.8
                });

                // M√°s manchas de sangre por todo el hospital
                for (let i = 0; i < 50; i++) {
                    const x = -80 + Math.random() * 160;
                    const z = -80 + Math.random() * 160;
                    const size = 0.3 + Math.random() * 1.5;

                    const bloodStain = new THREE.Mesh(
                        new THREE.CircleGeometry(size, 8),
                        bloodMaterial
                    );
                    bloodStain.rotation.x = -Math.PI / 2;
                    bloodStain.position.set(x, 0.01, z);
                    this.scene.add(bloodStain);
                }

                // Salpicaduras en las paredes
                for (let i = 0; i < 30; i++) {
                    const x = -80 + Math.random() * 160;
                    const y = 0.5 + Math.random() * 3;
                    const z = Math.random() < 0.5 ? -89.9 : 89.9;

                    const wallBlood = new THREE.Mesh(
                        new THREE.CircleGeometry(0.2 + Math.random() * 0.4, 8),
                        bloodMaterial
                    );
                    wallBlood.position.set(x, y, z);
                    this.scene.add(wallBlood);
                }

                // Rastros de sangre (como si arrastraran algo)
                for (let i = 0; i < 10; i++) {
                    const startX = -70 + Math.random() * 140;
                    const startZ = -70 + Math.random() * 140;
                    
                    for (let j = 0; j < 20; j++) {
                        const trail = new THREE.Mesh(
                            new THREE.CircleGeometry(0.1 + Math.random() * 0.2, 6),
                            bloodMaterial
                        );
                        trail.rotation.x = -Math.PI / 2;
                        trail.position.set(startX + j * 0.5, 0.01, startZ + j * 0.3);
                        this.scene.add(trail);
                    }
                }
            }

            createDebris() {
                // Escombros m√°s detallados y terror√≠ficos
                for (let i = 0; i < 25; i++) {
                    const x = -80 + Math.random() * 160;
                    const z = -80 + Math.random() * 160;
                    
                    // Escombros de techo ca√≠do
                    const debris = new THREE.Mesh(
                        new THREE.BoxGeometry(1 + Math.random() * 2, 0.2, 1 + Math.random() * 2),
                        new THREE.MeshLambertMaterial({ color: 0x444444 })
                    );
                    debris.position.set(x, 0.1, z);
                    debris.rotation.y = Math.random() * Math.PI;
                    debris.castShadow = true;
                    this.scene.add(debris);
                }

                // Vidrios rotos m√°s realistas
                for (let i = 0; i < 15; i++) {
                    const x = -80 + Math.random() * 160;
                    const z = -80 + Math.random() * 160;
                    
                    const glass = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.8, 0.8),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xffffff,
                            transparent: true,
                            opacity: 0.4
                        })
                    );
                    glass.rotation.x = -Math.PI / 2 + (Math.random() - 0.5) * 0.5;
                    glass.position.set(x, 0.02, z);
                    this.scene.add(glass);
                }

                // Papeles m√©dicos esparcidos
                for (let i = 0; i < 30; i++) {
                    const x = -80 + Math.random() * 160;
                    const z = -80 + Math.random() * 160;
                    
                    const paper = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.3, 0.4),
                        new THREE.MeshLambertMaterial({ color: 0xf5f5dc })
                    );
                    paper.rotation.x = -Math.PI / 2;
                    paper.position.set(x, 0.01, z);
                    this.scene.add(paper);
                }
            }

            createLighting() {
                // Luz ambiental muy tenue para mayor terror
                const ambientLight = new THREE.AmbientLight(0x404040, 0.05);
                this.scene.add(ambientLight);

                this.createFlickeringLights();

                // Linterna mejorada
                this.flashlight.light = new THREE.SpotLight(0xffffff, 2.5, 30, Math.PI / 3.5, 0.2);
                this.flashlight.light.position.copy(this.camera.position);
                this.flashlight.light.target.position.set(0, 0, -1);
                this.flashlight.light.castShadow = true;
                this.flashlight.light.shadow.mapSize.width = 2048;
                this.flashlight.light.shadow.mapSize.height = 2048;
                this.scene.add(this.flashlight.light);
                this.scene.add(this.flashlight.light.target);
            }

            createFlickeringLights() {
                // Luces parpadeantes m√°s distribuidas
                const lightPositions = [
                    [-40, 5.5, -40], [0, 5.5, -40], [40, 5.5, -40],
                    [-40, 5.5, 0], [0, 5.5, 0], [40, 5.5, 0],
                    [-40, 5.5, 40], [0, 5.5, 40], [40, 5.5, 40],
                    // Segundo piso
                    [-40, 13.5, -40], [0, 13.5, -40], [40, 13.5, -40],
                    [-40, 13.5, 0], [0, 13.5, 0], [40, 13.5, 0],
                    [-40, 13.5, 40], [0, 13.5, 40], [40, 13.5, 40]
                ];
                
                lightPositions.forEach(pos => {
                    const light = new THREE.PointLight(0xffffff, 0.2, 20);
                    light.position.set(...pos);
                    light.castShadow = true;
                    light.shadow.mapSize.width = 512;
                    light.shadow.mapSize.height = 512;
                    
                    light.userData = {
                        originalIntensity: 0.2,
                        flickerTime: Math.random() * 1000,
                        broken: Math.random() < 0.3
                    };
                    
                    this.scene.add(light);
                    
                    // Luminaria colgante
                    const fixture = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 0.3, 0.8),
                        new THREE.MeshLambertMaterial({ color: 0x666666 })
                    );
                    fixture.position.set(pos[0], pos[1] + 0.4, pos[2]);
                    fixture.castShadow = true;
                    this.scene.add(fixture);
                });
            }

            setupControls() {
                // Controles de escritorio
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key.toLowerCase() === ' ') {
                        e.preventDefault();
                        this.toggleFlashlight();
                    }
                    if (e.key.toLowerCase() === 'e') {
                        this.useStairs();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                document.addEventListener('click', () => {
                    this.toggleFlashlight();
                    if (!this.isMobile) {
                        document.body.requestPointerLock();
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === document.body && !this.isMobile) {
                        this.yaw -= (e.movementX || 0) * this.sensitivity;
                        this.pitch -= (e.movementY || 0) * this.sensitivity;
                        this.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.pitch));
                    }
                });

                // Controles m√≥viles
                if (this.isMobile) {
                    this.setupMobileControls();
                }

                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restart();
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setupMobileControls() {
                const joystickElement = document.getElementById('joystick');
                const joystickKnob = document.getElementById('joystickKnob');
                const flashlightBtn = document.getElementById('flashlightBtn');
                const useBtn = document.getElementById('useBtn');

                // Controles de joystick
                joystickElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.joystick.active = true;
                    const rect = joystickElement.getBoundingClientRect();
                    this.joystick.startX = rect.left + rect.width / 2;
                    this.joystick.startY = rect.top + rect.height / 2;
                });

                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    
                    if (this.joystick.active && e.touches.length > 0) {
                        const touch = e.touches[0];
                        const deltaX = touch.clientX - this.joystick.startX;
                        const deltaY = touch.clientY - this.joystick.startY;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        const maxDistance = 30;
                        
                        if (distance <= maxDistance) {
                            this.joystick.currentX = deltaX / maxDistance;
                            this.joystick.currentY = deltaY / maxDistance;
                            joystickKnob.style.transform = `translate(-50%, -50%) translate(${deltaX}px, ${deltaY}px)`;
                        } else {
                            const angle = Math.atan2(deltaY, deltaX);
                            this.joystick.currentX = Math.cos(angle);
                            this.joystick.currentY = Math.sin(angle);
                            joystickKnob.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle) * maxDistance}px, ${Math.sin(angle) * maxDistance}px)`;
                        }
                    }
                    
                    // Controles de mirada t√°ctil
                    if (e.touches.length > 1 || (!this.joystick.active && e.touches.length === 1)) {
                        const touch = e.touches[this.joystick.active ? 1 : 0];
                        if (this.touchLook.active) {
                            const deltaX = touch.clientX - this.touchLook.lastX;
                            const deltaY = touch.clientY - this.touchLook.lastY;
                            
                            this.yaw -= deltaX * this.sensitivity;
                            this.pitch -= deltaY * this.sensitivity;
                            this.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.pitch));
                        }
                        this.touchLook.active = true;
                        this.touchLook.lastX = touch.clientX;
                        this.touchLook.lastY = touch.clientY;
                    }
                });

                document.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.joystick.active = false;
                    this.joystick.currentX = 0;
                    this.joystick.currentY = 0;
                    this.touchLook.active = false;
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                });

                flashlightBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.toggleFlashlight();
                });

                useBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.useStairs();
                });
            }

            updatePlayer() {
                if (this.gameOver) return;

                const moveSpeed = this.player.speed;
                let newX = this.player.x;
                let newZ = this.player.z;

                // Calcular direcci√≥n de movimiento
                const forward = new THREE.Vector3(0, 0, -1);
                const right = new THREE.Vector3(1, 0, 0);
                
                // Aplicar rotaci√≥n de c√°mara a vectores de movimiento
                forward.applyEuler(new THREE.Euler(0, this.yaw, 0));
                right.applyEuler(new THREE.Euler(0, this.yaw, 0));

                // Movimiento de escritorio
                if (this.keys['w']) {
                    newX += forward.x * moveSpeed;
                    newZ += forward.z * moveSpeed;
                }
                if (this.keys['s']) {
                    newX -= forward.x * moveSpeed;
                    newZ -= forward.z * moveSpeed;
                }
                if (this.keys['a']) {
                    newX -= right.x * moveSpeed;
                    newZ -= right.z * moveSpeed;
                }
                if (this.keys['d']) {
                    newX += right.x * moveSpeed;
                    newZ += right.z * moveSpeed;
                }

                // Movimiento m√≥vil (joystick)
                if (this.isMobile && (this.joystick.currentX !== 0 || this.joystick.currentY !== 0)) {
                    newX += (forward.x * -this.joystick.currentY + right.x * this.joystick.currentX) * moveSpeed;
                    newZ += (forward.z * -this.joystick.currentY + right.z * this.joystick.currentX) * moveSpeed;
                }

                // Detecci√≥n de colisiones y l√≠mites
                if (newX > -88 && newX < 88 && newZ > -88 && newZ < 88) {
                    this.player.x = newX;
                    this.player.z = newZ;
                }

                // Verificar proximidad a escaleras
                const stairDistance = Math.sqrt(Math.pow(this.player.x - 0, 2) + Math.pow(this.player.z - 25, 2));
                this.nearStairs = stairDistance < 5;

                // Actualizar posici√≥n y rotaci√≥n de c√°mara
                this.camera.position.set(this.player.x, this.player.y + (this.player.currentFloor * 8), this.player.z);
                this.camera.rotation.set(this.pitch, this.yaw, 0);

                // Actualizar posici√≥n y direcci√≥n de la linterna
                if (this.flashlight.light) {
                    this.flashlight.light.position.copy(this.camera.position);
                    
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyEuler(new THREE.Euler(this.pitch, this.yaw, 0));
                    this.flashlight.light.target.position.copy(this.camera.position).add(direction);
                }

                // Drenaje de bater√≠a m√°s lento
                if (this.flashlight.on && this.flashlight.battery > 0) {
                    this.flashlight.battery -= this.flashlight.drainRate;
                    this.updateBatteryDisplay();
                    
                    if (this.flashlight.battery <= 0) {
                        this.flashlight.battery = 0;
                        this.flashlight.light.intensity = 0;
                    }
                }
            }

            useStairs() {
                if (this.nearStairs) {
                    this.player.currentFloor = this.player.currentFloor === 0 ? 1 : 0;
                    this.player.y = 1.7 + (this.player.currentFloor * 8);
                    
                    // Actualizar indicador de piso
                    document.getElementById('currentFloor').textContent = 
                        this.player.currentFloor === 0 ? 'Planta Baja' : 'Primer Piso';
                    
                    // Mover al jugador un poco para evitar bucle infinito
                    this.player.z += this.player.currentFloor === 0 ? -10 : 10;
                }
            }

            toggleFlashlight() {
                if (this.flashlight.battery > 0) {
                    this.flashlight.on = !this.flashlight.on;
                    if (this.flashlight.light) {
                        this.flashlight.light.intensity = this.flashlight.on ? 2.5 : 0;
                    }
                }
            }

            updateBatteryDisplay() {
                const batteryLevel = document.getElementById('batteryLevel');
                const batteryPercent = document.getElementById('batteryPercent');
                
                batteryLevel.style.width = `${Math.max(0, this.flashlight.battery)}%`;
                batteryPercent.textContent = `${Math.round(Math.max(0, this.flashlight.battery))}%`;
                
                if (this.flashlight.battery < 25) {
                    batteryLevel.style.background = '#F44336';
                } else if (this.flashlight.battery < 50) {
                    batteryLevel.style.background = '#FFC107';
                } else {
                    batteryLevel.style.background = '#4CAF50';
                }
            }

            startParanormalEvents() {
                setInterval(() => {
                    if (this.gameOver) return;
                    this.triggerParanormalEvent();
                }, 8000 + Math.random() * 12000);
            }

            triggerParanormalEvent() {
                const eventType = Math.random();
                
                if (eventType < 0.3) {
                    // Parpadeo de luces m√°s dram√°tico
                    this.scene.children.forEach(child => {
                        if (child.type === 'PointLight' && child.userData.originalIntensity) {
                            const originalIntensity = child.userData.originalIntensity;
                            child.intensity = Math.random() * originalIntensity * 0.5;
                            setTimeout(() => {
                                child.intensity = child.userData.broken ? 0 : originalIntensity;
                            }, 300 + Math.random() * 700);
                        }
                    });
                } else if (eventType < 0.5) {
                    // Drenaje s√∫bito de bater√≠a (menos agresivo)
                    this.flashlight.battery = Math.max(0, this.flashlight.battery - 8);
                    this.updateBatteryDisplay();
                } else if (eventType < 0.7) {
                    // Sombras movi√©ndose
                    this.addMovingShadow();
                } else if (eventType < 0.9) {
                    // Reducci√≥n temporal del alcance de la linterna
                    if (this.flashlight.light && this.flashlight.on) {
                        const originalDistance = this.flashlight.light.distance;
                        this.flashlight.light.distance = originalDistance * 0.4;
                        setTimeout(() => {
                            if (this.flashlight.on) this.flashlight.light.distance = originalDistance;
                        }, 4000);
                    }
                } else {
                    // Flash rojo aterrador
                    this.triggerJumpscare();
                }
            }

            addMovingShadow() {
                const shadowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.9
                });
                
                const shadow = new THREE.Mesh(
                    new THREE.PlaneGeometry(3, 6),
                    shadowMaterial
                );
                
                shadow.position.set(
                    -70 + Math.random() * 140,
                    2 + (this.player.currentFloor * 8),
                    -70 + Math.random() * 140
                );
                shadow.lookAt(this.camera.position);
                
                this.scene.add(shadow);
                
                setTimeout(() => {
                    this.scene.remove(shadow);
                }, 3000 + Math.random() * 4000);
            }

            triggerJumpscare() {
                // Flash rojo menos agresivo
                const flash = document.createElement('div');
                flash.style.position = 'fixed';
                flash.style.top = '0';
                flash.style.left = '0';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.backgroundColor = 'rgba(255, 0, 0, 0.4)';
                flash.style.zIndex = '1000';
                flash.style.pointerEvents = 'none';
                document.body.appendChild(flash);
                
                setTimeout(() => {
                    document.body.removeChild(flash);
                }, 150);

                // Reducir bater√≠a ligeramente
                this.flashlight.battery = Math.max(0, this.flashlight.battery - 5);
                this.updateBatteryDisplay();
            }

            gameLoop() {
                this.updatePlayer();
                this.timeElapsed++;
                
                // Actualizar luces parpadeantes
                this.scene.children.forEach(child => {
                    if (child.type === 'PointLight' && child.userData.flickerTime !== undefined) {
                        child.userData.flickerTime += 16;
                        if (child.userData.flickerTime > 3000 && Math.random() < 0.008) {
                            if (!child.userData.broken) {
                                child.intensity = Math.random() * child.userData.originalIntensity;
                                child.userData.flickerTime = 0;
                            }
                        }
                    }
                });
                
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.gameLoop());
            }

            restart() {
                this.gameOver = false;
                this.player.x = 0;
                this.player.z = 0;
                this.player.currentFloor = 0;
                this.player.y = 1.7;
                this.flashlight.battery = 100;
                this.flashlight.on = true;
                this.yaw = 0;
                this.pitch = 0;
                
                this.updateBatteryDisplay();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('currentFloor').textContent = 'Planta Baja';
                
                if (this.flashlight.light) {
                    this.flashlight.light.intensity = 2.5;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const game = new HorrorGame3D();
        });
    </script>
</body>
</html>